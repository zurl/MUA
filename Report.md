# MUA 解释器 实验报告

经历5天晚上的开发过程，这个解释器新鲜出炉了，下面主要描述下整个解释器的设计思路和难点突破。  
由于之前完成了一个JavaScript解释器，也对编译原理有所了解，所以整个项目并没有遇到太大的挫折。  
首先我考虑了下整个编译器的架构，暂时将他分成前端（BUFFER+词法分析+语法分析）和后端(Runtime)两部分。 

## 前端
首先由于这个语言的语法特性，前端部分非常容易完成。
* 缓冲  
首先把所有字符读入Buffer。
* 词法分析  
以空格或换行为界分词，通过第一个字符判断Token类型。
* 语法分析  
对词法分析出的Token将其按类别Parse，以弱类型Value的形式存在  
> 这个弱类型Value是Runtime中的核心部分  
> 原理是一个Struct 中有两个字段，一个enum类型表示type，一个union类型表示数据
> 根据type可以分辨出这个弱类型的当前数据类型  

最后将parse出的value以内置List的形式保存返回。

## 后端

后端有以下几个难点
* `函数调用`
* `符号表`
* `弱类型`
* `错误处理`
* `内存分配`

1.首先考虑符号表，我使用了定长哈希表作为主数据结构，char \* 为键value \*为值  

2.再考虑弱类型，内置的三种类型`word`和`literal`用字符串存放，`number`分类成int和doule,`bool`以int，`list` 通过以value*为data的链表存放。  
这里我考虑到符号的特殊性，增加了一些类型  
`null`表示空    
`function`表示为一个系统内置函数    
`funcstop`表示过程停止    

3.然后考虑错误处理，我简单的使用printf & return value(null)的方式处理，这样既简单又安全。 （都怪C没有exception  

4.然后考虑函数调用
先是自定义函数
函数调用本质是执行一个list，我为一个list创建一个listinstance用以执行，这样通过listinstance内部的指针就可以界定目前执行的位置。  
再者函数调用需要一个局部变量表，索性我就把符号表作为链表，函数调用时创建一个新的符号表，next指向全局表，把参数作为变量注入符号表，最后函数调用结束时清空符号表。  
最后偷个懒，直接把返回值放在叫"$"的变量里了。  
系统函数
考虑到系统函数参数不多，索性我建立了3个寄存器存参数，通过寄存器传递参数，返回值则直接作为C返回值返回。  
系统函数我也作为一种弱类型放入符号表，这样有利于程序结构的统一  

5.内存分配
全部使用malloc/free，内存模型参考C++，手动编写构造函数和析构函数，同时写一个复制构造函数，然后作用域结束手动调用析构函数。  

## 其他

### 关于全局变量
虽然用全局变量不好，但我还是用了几个我认为有必要的全局变量.  
symboltable  作为当前的符号表     
globaltable  作为全局符号表    
registerA/B/C 三个函数调用用到的寄存器  
registerTestFlag 存上次测试结果  
就用了这么几个，我觉得还是很有必要效果很好的。  
"所有事物还是不能一竿子打死的"  

### 关于工程化和敏捷开发
这次开发速度我很满意，主要是良好的架构的作用。  
最近写了两个middle-size-project都花费了很长的时间想架构，但我觉得非常有必要。
一旦架构完成，那么整个开发过程中思路将十分清晰,速度也非常快。  
这次的C语言项目 我将整个项目采用面向过程的思想，首先拆分成前端和后端。  
前端分成三个模块，很好开发，思路明确，组件复用。  
后端首先写好接口约束，自动依赖注入模块，还有eval和call这两个核心runtime。
这样用500行左右的代码就建立了框架，剩下的任务就是慢慢根据接口规范完成系统函数就行。
这次的经验值得学习。

### 关于依赖注入
函数表使用了依赖注入的方式，用了C语言仅有的函数指针的方式,我非常喜欢这种方式，
这种control over configuration的方式把写死在代码里的逻辑抽象了出来。
